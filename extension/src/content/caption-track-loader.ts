import type { SubtitleCue } from "@/types";

import { parseCaptionPayload } from "./caption-parser";

interface CaptionTrack {
  baseUrl?: string;
  languageCode?: string;
  kind?: string;
  vssId?: string;
}

interface TranscriptLoadResult {
  cues: SubtitleCue[];
  isAutoGenerated: boolean;
}

function isEnglishTrack(track: CaptionTrack): boolean {
  const languageCode = (track.languageCode || "").toLowerCase();
  const vssId = (track.vssId || "").toLowerCase();

  return languageCode.startsWith("en") || vssId.includes(".en");
}

function isAsrTrack(track: CaptionTrack): boolean {
  const vssId = (track.vssId || "").toLowerCase();
  return track.kind === "asr" || vssId.startsWith("a.");
}

function normalizeBaseUrl(input: string): string {
  return input.replace(/\\u0026/g, "&");
}

function forceFormat(baseUrl: string, fmt: "json3" | "srv3"): string {
  try {
    const url = new URL(normalizeBaseUrl(baseUrl));
    url.searchParams.set("fmt", fmt);
    return url.toString();
  } catch {
    const source = normalizeBaseUrl(baseUrl);
    if (source.includes("fmt=")) {
      return source.replace(/fmt=[^&]+/g, `fmt=${fmt}`);
    }
    return `${source}${source.includes("?") ? "&" : "?"}fmt=${fmt}`;
  }
}

function extractTracksFromResponse(response: unknown): CaptionTrack[] {
  const candidate = response as {
    captions?: {
      playerCaptionsTracklistRenderer?: { captionTracks?: CaptionTrack[] };
    };
  };

  const tracks =
    candidate?.captions?.playerCaptionsTracklistRenderer?.captionTracks;

  return Array.isArray(tracks) ? tracks : [];
}

function tryReadTracksFromWindow(): CaptionTrack[] {
  const fromInitial = extractTracksFromResponse(
    (window as unknown as { ytInitialPlayerResponse?: unknown })
      .ytInitialPlayerResponse
  );
  if (fromInitial.length > 0) {
    return fromInitial;
  }

  const rawPlayerResponse = (
    window as unknown as {
      ytplayer?: { config?: { args?: { player_response?: string } } };
    }
  ).ytplayer?.config?.args?.player_response;

  if (typeof rawPlayerResponse === "string" && rawPlayerResponse) {
    try {
      return extractTracksFromResponse(JSON.parse(rawPlayerResponse));
    } catch {
      return [];
    }
  }

  return [];
}

function pickEnglishTrack(tracks: CaptionTrack[]): CaptionTrack | null {
  const englishTracks = tracks.filter(isEnglishTrack);
  if (englishTracks.length === 0) {
    return null;
  }

  const manual = englishTracks.find((track) => !isAsrTrack(track));
  return manual || englishTracks[0] || null;
}

async function fetchCaptionCues(baseUrl: string): Promise<SubtitleCue[]> {
  const candidates = [forceFormat(baseUrl, "json3"), forceFormat(baseUrl, "srv3")];

  for (const url of candidates) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        continue;
      }

      const payload = await response.text();
      const cues = parseCaptionPayload(payload);
      if (cues.length > 0) {
        return cues;
      }
    } catch (error) {
      console.warn("[LingText] Caption track fetch failed:", error);
    }
  }

  return [];
}

async function fetchDirectApi(videoId: string): Promise<SubtitleCue[]> {
  const urls = [
    `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=json3`,
    `https://www.youtube.com/api/timedtext?v=${videoId}&lang=en&fmt=srv3`,
  ];

  for (const url of urls) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        continue;
      }

      const payload = await response.text();
      const cues = parseCaptionPayload(payload);
      if (cues.length > 0) {
        return cues;
      }
    } catch (error) {
      console.warn("[LingText] Direct caption API failed:", error);
    }
  }

  return [];
}

export async function loadEnglishTranscript(
  videoId: string
): Promise<TranscriptLoadResult | null> {
  const tracks = tryReadTracksFromWindow();
  const selectedTrack = pickEnglishTrack(tracks);

  if (selectedTrack?.baseUrl) {
    const cues = await fetchCaptionCues(selectedTrack.baseUrl);
    if (cues.length > 0) {
      return {
        cues,
        isAutoGenerated: isAsrTrack(selectedTrack),
      };
    }
  }

  const directApiCues = await fetchDirectApi(videoId);
  if (directApiCues.length > 0) {
    return {
      cues: directApiCues,
      isAutoGenerated: true,
    };
  }

  return null;
}
