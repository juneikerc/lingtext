import type { SubtitleCue } from "@/types";
import { normalizeWord, tokenize } from "@/utils/tokenize";

interface StabilizeOptions {
  isAutoGenerated: boolean;
}

function normalizeText(input: string): string {
  return input.replace(/\s+/g, " ").trim();
}

function splitWords(input: string): string[] {
  return tokenize(input)
    .filter((token) => token.isWord)
    .map((token) => token.lower || normalizeWord(token.text))
    .filter(Boolean);
}

function stripLeadingWords(input: string, count: number): string {
  if (count <= 0) {
    return input;
  }

  const tokens = tokenize(input);
  let seenWords = 0;
  let started = false;
  let output = "";

  for (const token of tokens) {
    if (!started) {
      if (token.isWord) {
        seenWords += 1;
        if (seenWords > count) {
          started = true;
          output += token.text;
        }
      }
      continue;
    }

    output += token.text;
  }

  return output.trimStart();
}

function findWordOverlap(prev: string[], next: string[]): number {
  const max = Math.min(prev.length, next.length);

  for (let size = max; size >= 1; size -= 1) {
    let match = true;

    for (let index = 0; index < size; index += 1) {
      if (prev[prev.length - size + index] !== next[index]) {
        match = false;
        break;
      }
    }

    if (match) {
      return size;
    }
  }

  return 0;
}

function mergeTexts(prevText: string, nextText: string): string {
  if (!nextText) {
    return prevText;
  }

  if (nextText === prevText) {
    return prevText;
  }

  if (nextText.startsWith(prevText)) {
    return nextText;
  }

  if (prevText.startsWith(nextText)) {
    return prevText;
  }

  const prevWords = splitWords(prevText);
  const nextWords = splitWords(nextText);
  const overlap = findWordOverlap(prevWords, nextWords);
  const suffix = stripLeadingWords(nextText, overlap);

  if (!suffix) {
    return prevText;
  }

  const separator = /^[,.;:!?)]/.test(suffix) ? "" : " ";
  return `${prevText}${separator}${suffix}`.replace(/\s+/g, " ").trim();
}

function isIncrementalGrowth(prevText: string, nextText: string): boolean {
  if (!prevText || !nextText) {
    return false;
  }

  const prevNorm = normalizeText(prevText).toLowerCase();
  const nextNorm = normalizeText(nextText).toLowerCase();

  if (nextNorm.startsWith(prevNorm) && nextNorm.length > prevNorm.length) {
    return true;
  }

  const prevWords = splitWords(prevNorm);
  const nextWords = splitWords(nextNorm);

  if (nextWords.length <= prevWords.length) {
    return false;
  }

  let sharedPrefix = 0;
  const limit = Math.min(prevWords.length, nextWords.length);
  for (let i = 0; i < limit; i += 1) {
    if (prevWords[i] !== nextWords[i]) {
      break;
    }
    sharedPrefix += 1;
  }

  if (prevWords.length <= 2) {
    return sharedPrefix >= prevWords.length;
  }

  return sharedPrefix >= prevWords.length - 1;
}

function hasSentenceEnd(text: string): boolean {
  return /[.!?]["')\]]?$/.test(text.trim());
}

function getCueWordCount(text: string): number {
  return splitWords(text).length;
}

export function stabilizeCues(
  cues: SubtitleCue[],
  options: StabilizeOptions
): SubtitleCue[] {
  if (cues.length === 0) {
    return [];
  }

  const sorted = [...cues]
    .map((cue) => ({
      start: Math.max(0, cue.start),
      end: Math.max(cue.end, cue.start + 0.3),
      text: normalizeText(cue.text),
    }))
    .filter((cue) => cue.text.length > 0)
    .sort((a, b) => a.start - b.start || a.end - b.end);

  if (sorted.length === 0) {
    return [];
  }

  const merged: SubtitleCue[] = [];
  let current: SubtitleCue = { ...sorted[0] };

  const maxGap = options.isAutoGenerated ? 0.65 : 0.45;
  const maxDuration = options.isAutoGenerated ? 6.5 : 6;
  const maxChars = 84;
  const maxWords = 18;

  for (let i = 1; i < sorted.length; i += 1) {
    const next = sorted[i];

    if (isIncrementalGrowth(current.text, next.text)) {
      current.text = next.text;
      current.end = Math.max(current.end, next.end);
      continue;
    }

    const gap = next.start - current.end;
    const combinedText = mergeTexts(current.text, next.text);
    const combinedDuration = Math.max(next.end, current.end) - current.start;
    const canMergeByLimits =
      gap <= maxGap &&
      combinedDuration <= maxDuration &&
      combinedText.length <= maxChars &&
      getCueWordCount(combinedText) <= maxWords;

    const shouldBreakForSentence = hasSentenceEnd(current.text);

    if (canMergeByLimits && (!shouldBreakForSentence || options.isAutoGenerated)) {
      current = {
        start: current.start,
        end: Math.max(current.end, next.end),
        text: combinedText,
      };
      continue;
    }

    merged.push(current);
    current = { ...next };
  }

  merged.push(current);

  // Remove accidental duplicates after merge.
  const deduped: SubtitleCue[] = [];
  for (const cue of merged) {
    const last = deduped[deduped.length - 1];
    if (
      last &&
      last.text === cue.text &&
      Math.abs(last.end - cue.start) < 0.2
    ) {
      last.end = Math.max(last.end, cue.end);
      continue;
    }
    deduped.push(cue);
  }

  return deduped;
}
